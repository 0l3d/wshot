#+TITLE: How to build a simple screenshot tool for Wayland.
#+AUTHOR: 0l3d
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css" />
#+HTML_DOCTYPE: html5
#+HTML_HEAD_EXTRA: <meta charset="UTF-8">

* Welcome

Hello, after struggling with the Wayland API for a while, I realized that after some time it becomes understandable, and for this reason, I decided to write a simple document about it.

** Making a screenshot program for Wayland

Required dependencies (I use Void Linux, so I wrote their names accordingly; you should find the equivalents for your own distribution):
- wayland-devel
- wlroots-devel
- wlr-screencopy-unstable-v1 protocol. (In the next section, you can find what it is and how to obtain it; this is not a distribution-specific dependency.)

*** What is wlr-screencopy
This protocol lets clients request the compositor to copy screen content to their buffers. It’s experimental and may change incompatibly until it becomes stable.

**** How can I install it or how can I get it?
Actually, I will give you an example from the .xml file I provided in my project; you can use it too. Of course, if you want, copies can also be found web.

First, we will generate header and source files from the XML file I provided, to use them in our project.
#+BEGIN_SRC bash
# HEADER FILE 
wayland-scanner client-header ./protocol/wlr-screencopy-unstable-v1.xml wlr-screencopy-unstable-v1.h

# SOURCE FILE 
wayland-scanner private-code ./protocol/wlr-screencopy-unstable-v1.xml wlr-screencopy-unstable-v1.c
#+END_SRC

We have two files, and we will use them in our project.


** WAYLAND BASICS
Actually, working with Wayland from scratch at a low level in C is easy but takes a long time to fully understand. Right now, I still don’t even know how to handle multiple monitors. Anyway, first of all, since I don’t want to bother explaining everything to you, I’m giving you the lines you need to =#include= in your C code from the very beginning. If you really want to, and you’re not an experienced C developer, you can research them one by one.
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <png.h>
#include <zlib.h>
#include <sys/syscall.h>
#include <wayland-client.h>
#include <linux/memfd.h>
#include "./wlr-screencopy-unstable-v1.h"
#+END_SRC

These =#include= statements are the libraries we will use.

** Connecting to Wayland Server
I defined two global variables to connect to the Wayland server.
#+BEGIN_SRC c
struct wl_display *display = NULL;
struct wl_registry *registry = NULL;
#+END_SRC
And along with that, I connected to the Wayland display using these functions.

#+BEGIN_SRC c
int main(int argc, char *argv[]) {
  display = wl_display_connect(NULL);
  if (!display) { // ERROR CHECKING.
    fprintf(stderr, "Unable to connect wayland display.");
    return 1;
  }
}
#+END_SRC
Now, assuming we have connected to the Wayland server, our first goal is to register objects and protocols using =wl_display_get_registry=. Additionally, we will set up a listener because there are things we need to catch!

Again, in our main code
#+BEGIN_SRC c
registry = wl_display_get_registry(display);
wl_registry_add_listener(registry, &reg_listener, NULL); // REGISTRY LISTENER
#+END_SRC

Now we have created the registry and opened a listener, but which function will this listener work with? Here is where our =reg_listener=, which we created as a =wl_registry_listener= struct, comes into play.

#+BEGIN_SRC c
struct wl_registry_listener reg_listener = {
  .global = reg_glob,
  .global_remove = reg_glob_remove,
};
#+END_SRC

Now, let's explain what =.global= and =.global-remove= are. First of all, you can create an empty function for =.global-remove= because in a small-scale program, no one will care about it. The function we assign to =.global= will handle the catch process.

Now, let’s start writing the function named =reg_glob=.

#+BEGIN_SRC c
void reg_glob(
	      void *data, struct wl_registry *registry,
	      uint32_t id, const char *interface, uint32_t version
	      ) {}
#+END_SRC
First of all, our function will be defined like this.

There are two things I will explain here: when binding the registry, we need an id, interface, and version. Actually, the struct handles the id and version for us; we only need to catch the necessary things with the interface.

#+BEGIN_SRC c
if (strcmp(interface, "wl_output") == 0) {
  st.output = wl_registry_bind(registry, id, &wl_output_interface, version);
}
#+END_SRC

Our first piece of code — let’s explain this code first. Here, we simply catch =wl_output= using the interface and bind it to a struct named st via registry bind. And yes, we don’t actually have a struct named =st= yet — so let’s define it now.

#+BEGIN_SRC c
struct state {
  struct wl_output *output;
  struct wl_shm *shm;
  struct zwlr_screencopy_manager_v1 *scrcopy;
};

struct state st;
#+END_SRC

Since explaining everything would take too much time, our =state= struct will look something like this. Also, we will declare =st= as a global variable.

